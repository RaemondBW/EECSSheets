\documentclass[3pt,landscape]{article}
%ss[10pt,landscape]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}


\pdfinfo{
/Title (final.pdf)
/Creator (TeX)
/Producer (pdfTeX 1.40.0)
/Author (Raemond Bergstrom-Wood)
/Subject (Algorithms)
/Keywords (pdflatex, latex,pdftex,tex)}

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.3in,left=.3in,right=.3in,bottom=.3in} }
    {\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
    }

% Turn off header and footer
\pagestyle{empty}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                            {-1ex plus -.5ex minus -.2ex}%
                            {0.5ex plus .2ex}%x
                            {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                            {-1explus -.5ex minus -.2ex}%
                            {0.5ex plus .2ex}%
                            {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                            {-1ex plus -.5ex minus -.2ex}%
                            {1ex plus .2ex}%
                            {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

%My Environments
\newtheorem{example}[section]{Example}
% -----------------------------------------------------------------------

\def\ci{\perp\!\!\!\perp}

\begin{document}
\raggedright
\footnotesize
\begin{multicols}{3}


% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
    \Large{\underline{CS 170 Final Cheat Sheet}} \\
\end{center}

\subsection*{Euclid's GCD: \(O(n^{3})\)}
\begin{verbatim}
def gcd(a,b):
    if b==0:
        return a
    return gcd(b, a mod b)
\end{verbatim}

\subsection*{Extended GCD: \(O(n^{3})\)}
\begin{verbatim}
def extended-gcd(a,b):
    if b==0:
        return (1, 0, a)
    (x', y', d) = extended-gcd(b, a mod b)
    return (y', x' - floor(a/b)*y', d)
\end{verbatim}
if d divides a and b and \(d=ax+by\) for some integers s and y,\\
then d = gcd(a, b)

\subsection*{Multiplicative Inverse}
inverse of a,
\[ax \equiv 1 (\texttt{mod } N)\]
for any \(a (\texttt{mod } N)\), a has a multiplicative inverse if and only if they are relatively prime, gcd(a,N) = 1

\subsection*{Fermat's Little Theorem}
% todo add the proof of this\\
given a prime (or carmichael) p,
\[a^{p-1} \equiv 1 (\texttt{mod } p)\]

\subsection*{RSA Euler's Theorem}
\[m^{(p-a)(q-1)}=1 (\texttt{mod } p)\]

\subsection*{Master's Theorem}
If
\[T(n)=aT(\lceil n/b \rceil)+O(n^{d}) \texttt{ for } a>0,b>1 \texttt{, and } d\geq 0,\]
then,
\[T(n)=\left\{\begin{array}{lr}
            O(n^{d}) & if d>log_{b}a\\
            O(n^{d}logn) & if d=log_{b}a\\
            O(n^{log_{b}a}) & if d < lob_{b}a
        \end{array}
        \right.\]

\subsection*{Fast Fourier Transform}
not done yet
% todo Add FFT Information Here

\subsection*{Search Algorithms}
\subsubsection*{Depth First Search}
\begin{verbatim}
def explore(G,v): #Where G = (V,E) of a Graph
    visited(v) = true
    previsit(v)
    for each edge(v,u) in E:
        if not visited(u):
            explore(u)
    postvisit(v)

def dfs(G):
    for all v in V:
        if not visited(v):
            explore(v)
\end{verbatim}
Previsit = count till node added to the queue\\
Postvisit = count till you leave the given node\\
A directed Graph has a cycle if it has a back edge found during DFS

\subsection*{Directed Acyclic Graphs}
Every DAG has a source and sink\\
% todo add more properties

\subsection*{Greedy Algorithms}
\subsubsection*{Kruskal's MST Algorithm \(O(E\log{v})\)}
Repeatedly add the next lightest edge that doesn't produce a cycle.
\begin{verbatim}
Input: A connected undirected graph G = (V,E) with edge 
        weights w
Output: A minimum spanning tree defined by the edges X

for all u in V:
    makeset(u)
X = {}
Sort the edges E by weight
for all edges {u,v} in E, in increasing order of weight:
    if find(u) != find(v):
        add edge {u,v} to X
        union(u,v)
\end{verbatim}
The above algorithm utilizes disjoint sets to determine whether adding a given edge creates a cycle. Basically by checking whether or not both sets have the same root ancestor.

\subsubsection*{Disjoint Sets Data Structure}
Contains a function, "find" that returns the root a given set.

\subsubsection*{Properties of Trees (undirected acyclic graphs)}
\begin{itemize}
    \item A tree with n nodes has n-1 edges
    \item Any connected undirected graph G(V,E), with \(|E|=|V|-1\) is a tree
    \item An undirected graph is a tree if and only if there is a unique path between any pair of nodes.
\end{itemize}

\subsubsection*{Cut Property}
Suppose edges X are part of a minimum spanning tree of \(G=(V,E)\). Pick any subset of nodes S for which X does not cross between S and V-S, and let e be the lightest edge across the partition. Then \(X \cup {e}\) is part of some Minimum Spanning Tree.

\subsubsection*{Prim's Algorithm}
(an alternative to Kruskal's Algorithm and similar to Dijkstras)\\
On each iteration, the subtreedefined by x grows by one edge, the lightest between a vertex in S and a vertex outside S.

\subsubsection*{Huffman Encoding}
A means to encode data using the optimal number of bits for each character given a distribution.
\begin{verbatim}
Huffman(f):
Input: An array f{1...n] of frequencies
Output: An encoding tree with n leaves

let H be a priority queue of integers, ordered by f
for i=1 to n: insert(H,i)
    i=deletemin(H), j=deletemin(H)
    create a node numbered k with children i,j
    f[k] = f[i]+f[j]
    insert(H,k)
\end{verbatim}

\subsubsection*{Horn Formulas}
Horn Formulas are a framework expressing logical facts and deriving conclusions. A Horn Clause is a possible solution to the Formulas. Variables are represented by two kinds of clauses:
\begin{enumerate}
    \item Implications, whose left-hand side is an AND of any numbers of positive literals and whose right-hand side is a signle positive literal. ("If the conditions on the left hold, then the one on the right mush also be true.")
        \[(z \wedge w) \Rightarrow u\]
    \item Pure negative clauses, consisting of an OR of any number of negative literals.
        \[(\bar{u} \vee \bar{v} \vee \bar{y})\]
\end{enumerate}
The a greedy algorithm to solve a Horn Formula:
\begin{verbatim}
Input: a Horn formula
Output: a satisfying assignment, if one exists

set all variables to false
while there is an implication that is not satisfied:
    set the right-hand variable of the implication to true
if all pure negative clases are satisfied:
    return the assignment
return 'The formula is not satisfiable.'
\end{verbatim}

\subsubsection*{Set Cover Algorithm}
(example. This is the Schools distributed across towns problem.)\\
\begin{verbatim}
Input: A set of elements B; sets S1,...,Sm
Output: A selection of the Si whose union is B.

Repeat until all elements of B are covered:
    Pick the set Si with the largest number of
            uncovered elements.
\end{verbatim}

\subsubsection*{Disjoint Sets Data Structure}
asdfjkl;
% todo

\subsection*{Dynamic Programming}
\subsubsection*{Longest Increasing Subsequence: \(O(n^{2})\)}
The following algorithm starts at one side of the list and finds the max length of sequences terminating at that given node, recursively following backlinks. Then given all the lengths of paths terminating at that given node choose the max length. Without memoization, this solution would be exponential time.
\begin{verbatim}
L = {}
for j=1,2,...,n:
    L[j] = 1+max{L[i]:(i,j) in E}
    # The (i,j) represents all the edges that go from
    # a node to j.
return max(L)
\end{verbatim}

\subsubsection*{Edit Distance (Spelling Suggestions)}
This algorithm works by basically choosing the min of the options for every given letter. (The 3 options being adding a gap inbetween letters of one of the strings or matching the two letters and moving on.)\\
ex) Snowy and Sunny have an edit distance of 3 with this configuration
\begin{verbatim}
S _ N O W Y
S U N N _ Y
\end{verbatim}
% todo finish dynamic programming information

\subsection*{Linear Programming}
\subsubsection*{Properties of Linear Programs}
\begin{enumerate}
    \item To turn a maximization problem into a minimization (or vice versa) just multiply the coeficients of the objective function by -1.
    \item To turn an inequality constraint like \(\sum_{i=1}^{n}a_i x_i \leq b\) into an equation, introduce a new variable S and use, \(\sum^n_{i=1}a_{i}x_{i}+s>b\), \(s \geq 0\) (S is known as a slack variable)
    \item To change an inequality constraint into inequalities rewrite \(ax=b\),\\
        as \(ax \leq b \texttt{ and } ax \geq b\)
    \item If a linear program has an unbounded value then its dual must be infeasible.
\end{enumerate}

\subsubsection*{Solving Linear Programs with the Simplex method}
typically polynomial time, but in worst case, exponential
\begin{verbatim}
let v be any vertex of the feasible region
while there is a neighbor v' of v with a better value:
    set v = v'
return v
\end{verbatim}
This is easily seen in a 2d or even sometimes a 3d graph of the constraints

\subsubsection*{Proving Optimality of a Linear Program Result, Duality}
max \(x_{1}+6x_{2}\)\\
\(\begin{array}{lc}
    \texttt{Inequality} & \texttt{multiplier}\\
    x_{1} \leq 200 & y_{1}\\
    x_{2} \leq 300 & y_{2}\\
    x_{1}+x_{2} \leq 400 & y_{3}\\
    x_{1},x_{2} \geq 0
\end{array}\)
\((y_{1}+y_{2})x_{1} + (y_{2}+y_{3})x_{2} \leq 200y_{1}+300y_{2}+400y_{3}\)\\
resulting in,\\
\(\texttt{min } 200y_{1}+300y_{2}+400y_{3}\)\\
\(y_{1}+y_{3} \geq 1\)\\
\(y_{2}+y_{3} \geq 6\)\\
\(y_{1},y_{2},y_{3} \geq 0\)\\
Which both result in the same optimum (via simplex) thus proving optimality.

\subsubsection*{Zero Sum Games}
% todo need to add information about zero sum games

\subsubsection*{Max Flow Algorithm}
Start with zero flow.\\
Repeat:\\
Choose an appropriate path from s to t, and increase flow along the edges of this path as much as possible.

\subsubsection*{Max Flow Min Cut Theorem}
The size of the maximum flow in a network equals the capacity of the smallest (s,t)-cut, where and (s,t)-cut partitions the vertices into two disjoint groups L and R such that s (start) is in L and t (goal) is in R.

\subsubsection*{Bipartite Matching}


% You can even have references
\rule{0.3\linewidth}{0.25pt}
\scriptsize
\bibliographystyle{abstract}
\bibliography{refFile}
\end{multicols}
\end{document}
